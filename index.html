<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>INFO 3300: Project 1</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .gridlines line {
      stroke: #e2e2e2;
    }

    .line {
      fill: none;
      stroke: #7a6060;
      stroke-width: 2px;
    }

    body {
      color: #4f3839;
      background-color: #7a6060;
      width: 960px;
      margin: auto;
      font-family: 'Trebuchet MS', sans-serif;
    }

    text {
      font-weight: bold;
      color: #7b6d6d
    }

    h3 {
      margin-left: 0px;
      margin-right: 0px;
      margin-bottom: 0px;
      margin-top: 50px;
      font-size: 40px;
      color: #f3e5e5;
      width: 78%;
      text-transform: lowercase;
      text-align: center;
      background-color: #d6afaf;
      padding: 68px;
      padding-top: 80px;
      border-top-left-radius: 80px;
      border-top-right-radius: 80px;
    }

    .main {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .all-graphs {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #F4F3EE;
      padding: 43px;
      border-bottom-left-radius: 80px;
      border-bottom-right-radius: 80px;
      margin-bottom: 80px;
    }

    #lineGraph {
      margin-top: 50px;
    }

    #colorLegend {
      margin-top: 10px;
      margin-left: 40px
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>

  <div class="main">


    <h3>The Dancability of the Top 100 Songs
      (2000-2023)</h3>
    <div class="all-graphs">
      <svg id="colorLegend" height="70" width="760"></svg>
      <svg id="songs" height="600" width="800"></svg>
      <svg id="lineGraph" height="600" width="800"></svg>

      <script>
        function jitter() {
          return Math.floor(Math.random() * 7) - 3;
        }
        d3.csv('15Songs20to23.csv', d3.autoType)
          .then((data) => {
            console.log(data);
            const svg = d3.select("svg#songs");
            const width = svg.attr("width");
            const height = svg.attr("height");
            const margins = { top: 10, right: 10, bottom: 50, left: 50 };
            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;
            let chartArea = svg.append("g")
              .attr("transform", "translate(" + margins.left + "," + margins.top + ")");

            const xExtent = d3.extent(data, d => d['energy']);
            const xScale = d3.scaleLinear().domain(xExtent)
              .range([0, chartWidth]);

            const yExtent = d3.extent(data, d => d['danceability']);
            const yScale = d3.scaleLinear()
              .domain([0, 100])
              .range([chartHeight, 0]);

            // SCATTER GRAPH
            const valExtent = d3.extent(data, d => d['valence']);
            const colorScale = d3.scaleSequential(d3.interpolatePlasma)
              .domain(valExtent);

            const circles = chartArea.selectAll('circle')
              .data(data)
              .join('circle')
              .attr('cx', d => xScale(d['energy']) + jitter())
              .attr('cy', d => yScale(d['danceability']) + jitter())
              .attr('r', 6)
              .attr('opacity', 0.5)
              .style('fill', d => colorScale(d['valence']));

            // GRID LINES
            let leftAxis = d3.axisLeft(yScale);
            svg.append('g')
              .attr('class', 'y axis')
              .attr('transform', `translate(${margins.left},${margins.top})`)
              .call(leftAxis);

            let leftGridlines = d3.axisLeft(yScale)
              .tickSize(-chartWidth)
              .tickFormat('');

            svg.append('g')
              .attr('class', 'y gridlines')
              .attr('transform', `translate(${margins.left},${margins.top})`)
              .call(leftGridlines);

            let bottomAxis = d3.axisBottom(xScale)
              .tickFormat(d3.format("d"))
            let element = svg.append('g')
              .attr('class', 'x axis')
              .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
              .call(bottomAxis)

            let bottomGridlines = d3.axisBottom(xScale)
              .tickSize(-chartHeight)
              .tickFormat('')
              .ticks(20);
            svg.append('g')
              .attr('class', 'x gridlines')
              .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
              .call(bottomGridlines);

            svg.append("text")
              .attr("x", margins.left + chartWidth / 2)
              .attr("y", chartHeight + margins.top + 45)
              .attr("text-anchor", "middle")
              .attr("fill", "#7a6060")
              .text("energy");

            svg.append("text")
              .attr("x", -(margins.top + chartHeight / 2))
              .attr("y", 16)
              .attr("transform", "rotate(-90)")
              .attr("fill", "#7a6060")
              .attr("text-anchor", "middle")
              .text("danceability");

            drawLegend("#colorLegend", colorScale);

            // LINE GRAPH:
            // calculating average dancability over the years
            const danceByYear = d3.groups(data, d => d.year)
              .map(([year, values]) => ({
                year: year,
                avgDanceability: d3.mean(values, d => d.danceability)
              }));

            const lineSvg = d3.select("svg#lineGraph");
            const lineChartHeight = height - margins.top - margins.bottom;
            const xYearExtent = d3.extent(danceByYear, d => d.year);
            const xYearScale = d3.scaleLinear()
              .domain(xYearExtent)
              .range([0, chartWidth]);

            const yDanceExtent = d3.extent(danceByYear, d => d.avgDanceability);
            const yDanceScale = d3.scaleLinear()
              .domain([58, 74])
              .range([lineChartHeight, 0]);

            const lineGenerator = d3.line()
              .x(d => xYearScale(d['year']))
              .y(d => yDanceScale(d.avgDanceability));

            const lineChartArea = lineSvg.append("g")
              .attr("transform", "translate(" + margins.left + "," + margins.top + ")");

            lineChartArea.append('path')
              .datum(danceByYear)
              .attr('fill', 'none')
              .attr('stroke', '#7a6060')
              .attr('stroke-width', 2)
              .attr('d', lineGenerator);

            // add circles for the year on the line
            lineChartArea.selectAll('circle')
              .data(danceByYear)
              .enter()
              .append('circle')
              .attr('cx', d => xYearScale(d.year))
              .attr('cy', d => yDanceScale(d.avgDanceability))
              .attr('r', 3)
              .attr('fill', '#7a6060')

            let leftAxisDanceability = d3.axisLeft(yDanceScale)
              .ticks(20);

            let leftLineGrid = d3.axisLeft(yDanceScale)
              .tickSize(-chartWidth)
              .tickFormat('');

            let bottomLineGrid = d3.axisBottom(xYearScale)
              .tickSize(-lineChartHeight)
              .tickFormat('')
              .ticks(10);

            lineSvg.append('g')
              .attr('class', 'gridlines')
              .attr('transform', `translate(${margins.left},${margins.top})`)
              .call(leftLineGrid);
            lineSvg.append('g')
              .attr('class', 'gridlines')
              .attr('transform', `translate(${margins.left},${lineChartHeight + margins.top})`)
              .call(bottomLineGrid);

            lineSvg.append('g')
              .attr('class', 'y axis danceability')
              .attr('transform', `translate(${margins.left},${margins.top})`)
              .call(leftAxisDanceability);

            let bottomAxisLineGraph = d3.axisBottom(xYearScale)
              .tickFormat(d3.format("d"));
            lineSvg.append('g')
              .attr('class', 'x axis')
              .attr('transform', `translate(${margins.left},${lineChartHeight + margins.top})`)
              .call(bottomAxisLineGraph);

            lineSvg.append("text")
              .attr("x", margins.left + (width - margins.left - margins.right) / 2)
              .attr("y", lineChartHeight + margins.top + 45)
              .attr("text-anchor", "middle")
              .attr("fill", "#7a6060")
              .text("year");

            lineSvg.append("text")
              .attr("x", -(margins.top + lineChartHeight / 2))
              .attr("y", 16)
              .attr("transform", "rotate(-90)")
              .attr("text-anchor", "middle")
              .attr("fill", "#7a6060")
              .text("average danceability");

            chartArea.raise();
            lineChartArea.raise();

          });
      </script>


      <script>
        function drawLegend(legendSelector, legendColorScale) {
          const offsets = {
            width: 10,
            top: 0,
            bottom: 25
          };
          const stepSize = 4;
          const minMaxExtendPercent = 0;
          const legend = d3.select(legendSelector);
          const legendHeight = legend.attr("height");
          const legendBarWidth = legend.attr("width") - (offsets.width * 2);
          const legendMinMax = d3.extent(legendColorScale.domain());
          const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
          const barHeight = legendHeight - offsets.top - offsets.bottom;

          let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
          legendMinMax[1] + minMaxExtension])
            .range([0, legendBarWidth]);
          let barAxis = d3.axisBottom(barScale);

          let bar = legend.append("g")
            .attr("class", "legend colorbar")
            .attr("transform", `translate(${offsets.width},${offsets.top})`)

          if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
            let thresholds = [];
            if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
            else { thresholds = legendColorScale.quantiles() }

            const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

            barAxis.tickValues(barThresholds);

            for (let i = 0; i < barThresholds.length - 1; i++) {
              let dataStart = barThresholds[i];
              let dataEnd = barThresholds[i + 1];
              let pixelStart = barAxis.scale()(dataStart);
              let pixelEnd = barAxis.scale()(dataEnd);

              bar.append("rect")
                .attr("x", pixelStart)
                .attr("y", 0)
                .attr("width", pixelEnd - pixelStart)
                .attr("height", barHeight)
                .style("fill", legendColorScale((dataStart + dataEnd) / 2.0));
            }
          }
          else if (legendColorScale.hasOwnProperty('rangeRound')) {

            for (let i = 0; i < legendBarWidth; i = i + stepSize) {

              let center = i + (stepSize / 2);
              let dataCenter = barAxis.scale().invert(center);

              if (dataCenter < legendMinMax[0]) {
                bar.append("rect")
                  .attr("x", i)
                  .attr("y", 0)
                  .attr("width", stepSize)
                  .attr("height", barHeight)
                  .style("fill", legendColorScale(legendMinMax[0]));
              }
              else if (dataCenter < legendMinMax[1]) {
                bar.append("rect")
                  .attr("x", i)
                  .attr("y", 0)
                  .attr("width", stepSize)
                  .attr("height", barHeight)
                  .style("fill", legendColorScale(dataCenter));
              }
              else {
                bar.append("rect")
                  .attr("x", i)
                  .attr("y", 0)
                  .attr("width", stepSize)
                  .attr("height", barHeight)
                  .style("fill", legendColorScale(legendMinMax[1]));
              }

            }
          }
          else {
            let nomVals = legendColorScale.domain().sort();

            let barScale = d3.scaleBand().domain(nomVals)
              .range([0, legendBarWidth])
              .padding(0.05);
            barAxis.scale(barScale);

            nomVals.forEach(d => {
              bar.append("rect")
                .attr("x", barScale(d))
                .attr("y", 0)
                .attr("width", barScale.bandwidth())
                .attr("height", barHeight)
                .style("fill", legendColorScale(d));
            });
          }
          legend.append("g")
            .attr("class", "legend axis")
            .attr("transform", `translate(${offsets.width},${offsets.top + barHeight})`)
            .call(barAxis);

          legend.append("text")
            .attr("x", offsets.width + (legendBarWidth / 2))
            .attr("y", 30)
            .attr("text-anchor", "middle")
            .style("fill", "white")
            .text("valence");

        }
      </script>
    </div>
  </div>
</body>

</html>