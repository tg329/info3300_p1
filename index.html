<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>INFO 3300: Project 1</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .gridlines line {
      stroke: #e2e2e2;
    }

    .line {
      fill: none;
      stroke: #984f4f;
      stroke-width: 2px;
    }

    body {
      color: #633638;
      background-color: #815454;
      margin: auto;
      font-family: 'Trebuchet MS', sans-serif;
    }

    text {
      font-weight: bold;
      color: #792e2e
    }

    h3 {
      font-size: 40px;
      color: #fffbfb;
      text-transform: lowercase;
      text-align: center;
      margin: 10px;
    }

    h4 {
      font-size: 28px;
      color: #ce8d8d;
      margin: 0px;
      margin-bottom: 30px;
    }

    .style-h {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin-left: 0px;
      margin-right: 0px;
      margin-bottom: 0px;
      margin-top: 50px;
      width: 850px;
      background-color: #db9b9b;
      padding: 68px;
      border-top-left-radius: 80px;
      border-top-right-radius: 80px;
      text-align: center;
    }

    .h-descr {
      margin: 0px;
      font-size: 23px;
      color: #fffbfb;
      text-transform: lowercase;
      text-align: center;

    }

    .main {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .all-graphs {
      display: flex;
      font-style: oblique;
      flex-direction: column;
      align-items: center;
      background-color: #F4F3EE;
      padding: 93px;
      padding-top: 60px;
      padding-bottom: 10px;
      border-bottom-left-radius: 25px;
      border-bottom-right-radius: 25px;
      margin-bottom: 30px;
    }

    #colorLegend {
      margin: 0px;
      margin-left: 40px
    }

    .group-members {
      display: flex;
      flex-direction: column;
      gap: 0px;
      padding: 30px;
      background-color: #db9b9b60;
      text-align: center;
      margin-bottom: 80px;
      border-radius: 35px;
    }

    .gm-decr {
      margin: 0px;
      padding: 5px;
      font-size: 18px;
      color: #2b060665
    }

    .graph-desc {
      color: #cd8989;
      font-size: 12px;
      padding: 18px;
      margin: 30px;
      margin-bottom: 80px;
      background-color: #db9b9b30;
      border-radius: 10px;
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>

  <div class="main">
    <div class="style-h">
      <h3>Dancability of the Top 100 Songs</h3>
      <p class="h-descr">(2000 to 2023)</p>
    </div>
    <div class="all-graphs">

      <!--  ########## SVG ELEMENTS GRAPH: ########## -->
      <h4>valence and energy's effect on dancability</h4>
      <svg id="colorLegend" height="70" width="760"></svg>
      <svg id="songs" height="600" width="800"></svg>
      <p class="graph-desc">

        This graph visualizes the impact of valence (how positive a song feels) and energy (a measure of intensity and activity, from 0% to 100%) on a song's danceability, which reflects how suitable a track is for dancing, based on factors like tempo, rhythm stability, beat strength, and regularity. From this graph, we can see that a higher energy song that feels more positive is generally associated with a higher danceability rating.
      </p>


      <h4>average dancability over the years</h4>
      <svg id="lineGraph" height="600" width="800"></svg>
      <p class="graph-desc">
        This graph measures average danceability over the years, showing trends with noticeable dips and peaks, the lowest occurring in 2012-2013 and the highest in 2018 and 2022.
      </p>
      <!--  ########## SCATTER GRAPH: ########## -->
      <script>
        function jitter() {
          return Math.floor(Math.random() * 7) - 3;
        }
        d3.csv('15Songs20to23.csv', d3.autoType)
          .then((data) => {
            // console.log(data);
            const svg = d3.select("svg#songs");
            const width = svg.attr("width");
            const height = svg.attr("height");
            const margins = { top: 10, right: 10, bottom: 50, left: 50 };
            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;
            let chartArea = svg.append("g")
              .attr("transform", "translate(" + margins.left + "," + margins.top + ")");

            const xExtent = d3.extent(data, d => d['energy']);
            const xScale = d3.scaleLinear().domain(xExtent)
              .range([0, chartWidth]);

            const yExtent = d3.extent(data, d => d['danceability']);
            const yScale = d3.scaleLinear()
              .domain([0, 100])
              .range([chartHeight, 0]);

            // SCATTER GRAPH
            const valExtent = d3.extent(data, d => d['valence']);
            const colorScale = d3.scaleSequential(d3.interpolatePlasma)
              .domain(valExtent);

            const circles = chartArea.selectAll('circle')
              .data(data)
              .join('circle')
              .attr('cx', d => xScale(d['energy']) + jitter())
              .attr('cy', d => yScale(d['danceability']) + jitter())
              .attr('r', 6)
              .attr('opacity', 0.5)
              .style('fill', d => colorScale(d['valence']));

            // GRID LINES
            let leftAxis = d3.axisLeft(yScale);
            svg.append('g')
              .attr('class', 'y axis')
              .attr('transform', `translate(${margins.left},${margins.top})`)
              .call(leftAxis);

            let leftGridlines = d3.axisLeft(yScale)
              .tickSize(-chartWidth)
              .tickFormat('');

            svg.append('g')
              .attr('class', 'y gridlines')
              .attr('transform', `translate(${margins.left},${margins.top})`)
              .call(leftGridlines);

            let bottomAxis = d3.axisBottom(xScale)
              .tickFormat(d3.format("d"))
            let element = svg.append('g')
              .attr('class', 'x axis')
              .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
              .call(bottomAxis)

            let bottomGridlines = d3.axisBottom(xScale)
              .tickSize(-chartHeight)
              .tickFormat('')
              .ticks(20);
            svg.append('g')
              .attr('class', 'x gridlines')
              .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
              .call(bottomGridlines);

            svg.append("text")
              .attr("x", margins.left + chartWidth / 2)
              .attr("y", chartHeight + margins.top + 45)
              .attr("text-anchor", "middle")
              .attr("fill", "#984f4f")
              .text("energy");

            svg.append("text")
              .attr("x", -(margins.top + chartHeight / 2))
              .attr("y", 16)
              .attr("transform", "rotate(-90)")
              .attr("fill", "#984f4f")
              .attr("text-anchor", "middle")
              .text("danceability");

            drawLegend("#colorLegend", colorScale);

            chartArea.raise();

          });
      </script>

      <!--  ########## LINE GRAPH: ########## -->
      <script>
        d3.dsv(';', 'bestSongs.csv', d3.autoType)
          .then((data) => {
            console.log(data);

            const svg = d3.select("svg#lineGraph");
            const width = +svg.attr("width");
            const height = +svg.attr("height");
            const margins = { top: 10, right: 10, bottom: 50, left: 50 };
            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;
            let chartArea = svg.append("g")
              .attr("transform", `translate(${margins.left}, ${margins.top})`);

            // calculating average danceability over the years
            const danceByYear = d3.groups(data, d => d.year)
              .map(([year, values]) => ({
                year: year,
                avgDanceability: d3.mean(values, d => d['danceability '])
              }))
              .filter(d => d.year >= 2000 && d.year <= 2023)
              .sort((a, b) => a.year - b.year);
            console.log(danceByYear);

            const lineChartArea = chartArea.append("g");

            const xYearExtent = d3.extent(danceByYear, d => d.year);
            const xYearScale = d3.scaleLinear()
              .domain(xYearExtent)
              .range([0, chartWidth]);

            const yDanceExtent = d3.extent(danceByYear, d => d.avgDanceability);
            const yDanceScale = d3.scaleLinear()
              .domain([62, 73])
              .range([chartHeight, 0]);

            const lineGenerator = d3.line()
              .x(d => xYearScale(d.year))
              .y(d => yDanceScale(d.avgDanceability));

            lineChartArea.append('path')
              .datum(danceByYear)
              .attr('fill', 'none')
              .attr('stroke', '#984f4f')
              .attr('stroke-width', 2)
              .attr('d', lineGenerator);

            // Add circles for each data point
            lineChartArea.selectAll('circle')
              .data(danceByYear)
              .enter()
              .append('circle')
              .attr('cx', d => xYearScale(d.year))
              .attr('cy', d => yDanceScale(d.avgDanceability))
              .attr('r', 3)
              .attr('fill', '#984f4f');

            let leftAxisDanceability = d3.axisLeft(yDanceScale)
              .ticks(20);

            let leftLineGrid = d3.axisLeft(yDanceScale)
              .tickSize(-chartWidth)
              .tickFormat('');

            let bottomLineGrid = d3.axisBottom(xYearScale)
              .tickSize(-chartHeight)
              .tickFormat('')
              .ticks(10);

            chartArea.append('g')
              .attr('class', 'gridlines')
              .call(leftLineGrid);

            chartArea.append('g')
              .attr('class', 'gridlines')
              .attr('transform', `translate(0, ${chartHeight})`)
              .call(bottomLineGrid);

            chartArea.append('g')
              .attr('class', 'y axis danceability')
              .call(leftAxisDanceability);

            let bottomAxisLineGraph = d3.axisBottom(xYearScale)
              .ticks(20)
              .tickFormat(d3.format("d"));

            chartArea.append('g')
              .attr('class', 'x axis')
              .attr('transform', `translate(0, ${chartHeight})`)
              .call(bottomAxisLineGraph);

            // tick direction 
            chartArea.selectAll('.x.axis text')
              .attr('transform', 'rotate(-45)')
              .attr('text-anchor', 'end')
              .attr('dx', '-0.5em')
              .attr('dy', '0.5em');

            // xaxis
            svg.append("text")
              .attr("x", margins.left + (chartWidth / 2))
              .attr("y", chartHeight + margins.top + 48)
              .attr("text-anchor", "middle")
              .attr("fill", "#984f4f")
              .text("year");

            // yaxis
            svg.append("text")
              .attr("x", -(margins.top + chartHeight / 2))
              .attr("y", 10)
              .attr("transform", "rotate(-90)")
              .attr("text-anchor", "middle")
              .attr("fill", "#984f4f")
              .text("average danceability");

            lineChartArea.raise();
          });
      </script>

      <!--  ########## LEGEND: ########## -->
      <script>
        function drawLegend(legendSelector, legendColorScale) {
          const offsets = {
            width: 10,
            top: 0,
            bottom: 25
          };
          const stepSize = 4;
          const minMaxExtendPercent = 0;
          const legend = d3.select(legendSelector);
          const legendHeight = legend.attr("height");
          const legendBarWidth = legend.attr("width") - (offsets.width * 2);
          const legendMinMax = d3.extent(legendColorScale.domain());
          const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
          const barHeight = legendHeight - offsets.top - offsets.bottom;

          let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
          legendMinMax[1] + minMaxExtension])
            .range([0, legendBarWidth]);
          let barAxis = d3.axisBottom(barScale);

          let bar = legend.append("g")
            .attr("class", "legend colorbar")
            .attr("transform", `translate(${offsets.width},${offsets.top})`)

          if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
            let thresholds = [];
            if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
            else { thresholds = legendColorScale.quantiles() }

            const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

            barAxis.tickValues(barThresholds);

            for (let i = 0; i < barThresholds.length - 1; i++) {
              let dataStart = barThresholds[i];
              let dataEnd = barThresholds[i + 1];
              let pixelStart = barAxis.scale()(dataStart);
              let pixelEnd = barAxis.scale()(dataEnd);

              bar.append("rect")
                .attr("x", pixelStart)
                .attr("y", 0)
                .attr("width", pixelEnd - pixelStart)
                .attr("height", barHeight)
                .style("fill", legendColorScale((dataStart + dataEnd) / 2.0));
            }
          }
          else if (legendColorScale.hasOwnProperty('rangeRound')) {

            for (let i = 0; i < legendBarWidth; i = i + stepSize) {

              let center = i + (stepSize / 2);
              let dataCenter = barAxis.scale().invert(center);

              if (dataCenter < legendMinMax[0]) {
                bar.append("rect")
                  .attr("x", i)
                  .attr("y", 0)
                  .attr("width", stepSize)
                  .attr("height", barHeight)
                  .style("fill", legendColorScale(legendMinMax[0]));
              }
              else if (dataCenter < legendMinMax[1]) {
                bar.append("rect")
                  .attr("x", i)
                  .attr("y", 0)
                  .attr("width", stepSize)
                  .attr("height", barHeight)
                  .style("fill", legendColorScale(dataCenter));
              }
              else {
                bar.append("rect")
                  .attr("x", i)
                  .attr("y", 0)
                  .attr("width", stepSize)
                  .attr("height", barHeight)
                  .style("fill", legendColorScale(legendMinMax[1]));
              }

            }
          }
          else {
            let nomVals = legendColorScale.domain().sort();

            let barScale = d3.scaleBand().domain(nomVals)
              .range([0, legendBarWidth])
              .padding(0.05);
            barAxis.scale(barScale);

            nomVals.forEach(d => {
              bar.append("rect")
                .attr("x", barScale(d))
                .attr("y", 0)
                .attr("width", barScale.bandwidth())
                .attr("height", barHeight)
                .style("fill", legendColorScale(d));
            });
          }
          legend.append("g")
            .attr("class", "legend axis")
            .attr("transform", `translate(${offsets.width},${offsets.top + barHeight})`)
            .call(barAxis);

          legend.append("text")
            .attr("x", offsets.width + (legendBarWidth / 2))
            .attr("y", 30)
            .attr("text-anchor", "middle")
            .style("fill", "white")
            .text("valence");

        }
      </script>
    </div>
    <div class="group-members">
      <p class="gm-decr"><b>project members</b></p>
      <p class="gm-decr">nicole lin (njl55,) shihan gao (tg329), elaine wu (ew457), jolly zheng (jz767)</p>
    </div>

  </div>
</body>

</html>